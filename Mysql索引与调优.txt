=========================================================
数据库索引

索引是什么
    在数据之外，数据库还维护着满足特定查找算法的数据结构，这些数据结构一某种方式引用（指向）数据，这样就可以在这些数据结构的基础上实现高级查找算法，这种数据结构就是索引
    B树索引（默认） 
    帮助mysql高效获取数据的数据结构，类比字典目录
    索引是排好序的快速查找的数据结构！
    一是排序（影响order by）
    二是查找（影响where）

    数据的增删改可能会导致索引失效，需要重建索引，开销大
    索引本身可能也很大，只能部分存储在内存中，往往以索引文件的形式存储在磁盘上
    一张表上最多有16个索引

索引结构
    B+Tree索引
        B+Tree是一种多路平衡查找树（树高比二叉平衡查找树要低）
        可以完成查找和排序两个工作
        非叶子节点只存放索引和指针（体积小，查询效率稳定）
        只在叶子节点存放实际的值（在InnoDB中，可能是主键索引，也可能是整行的值）。
        叶子节点有指针指向下一个叶子节点，因此对range qyuery有更高的性能。
        由于InnoDB引擎实际管理存储的最小单位是页，因此（聚簇索引）叶节点存放的内容不是一行数据，而是一整页，定位到页后需要在页内使用二分查找定位到行。
        叶节点的指针其实是指向含有下一个目标行的页。
        （和B+树不同，B树在非叶子节点也会存放值，导致非叶子节点体积变大，内存能存放的节点个数变少，IO开支可能变大）

    聚集索引和非聚集索引
        聚集（聚簇）索引（也叫做主键索引，目的是找到真实数据）：
            如果一张表有主键，那么会根据主键创建一个索引，通过整个索引可以指向真实的数据
            如果没有主键，会选择一个不为空的唯一索引作为聚集索引
            如果也没有，会生成一个隐式的六个字节的主键作为主键（用户不可访问）创建聚集索引
            在InnoDB中，聚集索引的叶子节点存放了整行数据
            聚集索引占用的空间非常大（表体积的120%），一张表只能有一个聚集索引
            使用聚集索引只用查找一次就可以得到数据
        非聚集索引（非主键索引，目的是找到主键）
            叶子节点中存放主键的值（可能会导致需要根据主键的值再去查找）
            一般来说聚簇索引要比非聚簇索引快
            如果使用了覆盖索引也可以实现一次查找（即要查找的列是所使用的索引的子集，那么可以通过索引获得全部想要的数据，不再需要通过主键再去查找一遍数据）


    Hash索引
        Hash索引底层是Hash表
        Hash索引适合等值查询，不适合范围查询（没有排序，因此也就无法借助Hash索引完成排序），区间索引要进行全表扫描
        Hash索引没有最佳左前缀匹配
        有大范围重复的情况下，Hash索引的效率会很低（因为存在Hash碰撞）
        Memory引擎使用的是Hash索引
        InnoDB在对某些内容频繁查找的情况下会建立一个自适应的Hash索引，用于加快查找速度

    full-text全文索引
    R-Tree索引

优势
    提高数据检索效率，降低数据库的IO成本
    通过索引对数据进行排序，降低数据的排序成本，降低了CPU消耗
劣势
    实际上索引也是一张表，保存了主键和索引字段，并指向表的记录，所以索引列也需要占用空间
    更新表时会引起索引文件的变化，导致更新操作变慢
    索引只是提高效率的一个因素，如果有大量的表，则举要花时间研究什么样的建索引方式最合适

基本语法
    创建索引
        CREATE [UNIQUE] INDEX indexname ON mytable(columnname1(length),……) （只写一个列就是单值索引，写多个就是复合索引）
        ALTER mytable ADD [UNIQUE] INDEX [indexname] ON (columnname1(length))
    删除
        DROP INDEX [indexname] ON mytable
    查看
        SHOW INDEX FROM table_name
    使用ALTER命令

索引的类型
    普通索引：最基本的索引，没有任何约束
    唯一索引：索引列的值必须唯一，但是允许有空值
    主键索引：主键索引肯定是唯一索引，但是不允许有空值
    外键索引：只有InnoDB引擎才可以使用外键索引（foreign key，一般不推荐使用，会增加表之间的依赖性，不安全）
    （）单值索引（使用一个字段值创建索引）
        即一个索引只包含单个列，一个表可以有多个单值索引（针对频繁查询的列，不然一般情况使用复合索引）（一张表一般索引不超过五个）
        创建语句
            create index idx_user_name on user(name) 
                解释：create index，创建索引的关键字；
                idx_user_name是一个命名习惯（idx表示这个字段是个索引，user表示是user表中的，name表示是根据表中的name字段）；
                on user(name)表示使用user表中的name字段
    复合索引
        即一个索引包含多个列
        创建语句
            create index idx_user_nameEmail on user(name，email)
            解释：使用多个常用字段创建索引

常见的join查询
    sql执行顺序
        手写顺序：select，from，where，group by，having，order by，limit
        执行顺序：from ，on， where，group by， having，select，distinct，order by，limit
    
    七种join
       A inner join B on A.key=B.key AB的交集（最后生成的临时表小于等于AB）
       A left join B on A.key=B.key A是主表，全部保留（生成的临时表和A一样大）
       A right join B on A.key=B.key B是主表，全部保留（生成的临时表和B一样大）
       A left join B on A.key=B.key where B.key is null A是主表，保留A中独有B中没有的
       A right join B on A.key=B.key where A.key is null B是主表，保留B中独有A中没有的
       A full outer join B on A.key=B.key 全连接
       A full outer join B on A.key=B.key where A.key is null or B.key is null AB中各自独有的

什么时候需要创建索引
    主键自动建立唯一索引
    频繁查询字段创建索引
    与其他表关联的字段，外键建立索引
    查询中排序的字段，排序字段通过索引访问能大大提高排序速度
    单值索引/复合索引？（高并发下倾向于创建组合索引）
    查询中统计或分组字段 

    频繁更新的字段不适合创建索引
    where用不到的字段不要创建索引

什么时候不要创建索引
    表记录太小（三百万以后mysql性能开始下降）
    经常增删改的表
    数据重复且分布平均的表字段
    索引选择性越低越不适合建索引
        索引选择性：指索引列中不同值的数目和表中记录数的比值。例如一个表中2000条记录，表索引列有1980个不同的值，则索引的选择性为1980/2000=0.99。索引选择性越接近1，索引的效率越高
    
索引优化分析
    性能下降：执行时间长、等待时间长
        查询语句没写好
        索引失效（单值索引，复合索引）
        查询关联太多join（设计缺陷或不得已的需求）
        服务器调优及各个参数的设置
        （主要关注前三个原因）

索引性能分析
    mysql query optimizer（查询优化器）的优化过程
        1.根据搜索条件，找出所有可能的索引
        2.计算全表扫描的代价
        3.计算使用不同索引的代价
        4.对比各种执行方案，找出成本最低的那一种

    mysql常见瓶颈
        CPU：CPU饱和一般发生在数据装入内存或者从磁盘读数据的时候
        IO：磁盘IO瓶颈发生在装入数据远大于内存容量的时候
        服务器硬件性能瓶颈：top、free、iostat和vmstat来查看系统的性能状态
    Explain
        是什么：查看执行计划（模拟优化器执行SQL查询语句，从而知道Mysql是如何处理程序员提交的Mysql语句。分析查询语句或是表结构的性能瓶颈）
        能做什么
            表的读取顺序
            数据读取操作的操作类型
            哪些索引可以被使用
            哪些索引实际被使用
            表之间的引用
            每张表有多少行被优化器查询
        怎么使用
            explain select * from table_name （explain关键词+sql查询语句）
                默认（分号结尾）是输出内容格式和数据库查询结果一致，第一行是字段名，下面几行是字段
                如果用\G结尾（不加分号），则按照竖版输出
            执行计划包含的信息
                explain字段有哪些
                    id,select_type,table,type,possible_keys,key,key_len,ref,rows,Extra
                需要额外关注哪些
                    id（执行顺序）
                    type（查找方式）
                    key（使用了什么索引，可以发现索引失效的情况）
                    rows（估计要扫描多少行得到查询结果，可以用来比较索引带来的效率提升）
                    Extra（其他十分重要的额外信息）

        字段解释
            id
                select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序
                id相同时，执行顺序由上到下
                id不同，如果是子查询，id序号会递增，id值越大优先级越高（越先执行）
                id的相同和不同同时存在，先执行数字大的，数字相同的按顺序执行
            select_type
                有哪些：
                    SIMPLE：简单查询，查询中不包含子查询或者UNION
                    PRIMARY：查询中如果包含任何复杂的子部分，则最外层被称为Primary查询
                    SUBQUERY：在select或where中包含了子查询
                    DERIVED：在from列表中包含的子查询会被标记为derived（衍生），mysql会递归执行这些子查询，结果放在临时表里
                    UNION：若第二个select出现在union之后，则被标记为UNION；如果union包含在from子句的子查询中，则外层select将被标记为derived
                    UNION RESULT：从union表中获取结果的select
                查询的类型，主要用于区别普通查询，联合查询，子查询和复杂查询
            table
                显示这一行的数据是关于哪张表的
            type
                ALL：表示全表扫描
                index：全索引扫描。和ALL的区别在于index类型只遍历索引（索引通常比数据列小，而且可能存放在内存中，ALL是从内存中读），
                range：只检索给定范围的行，例如使用了不等号，或者in关键字，使用一个索引来选择行。key列显示使用了哪个索引（一般的原因是where语句中出现between或者不等号或者in）。这种范围扫描要优于全表扫描，因为只要开始于索引的某一点，结束于另一点，不用扫描全部索引
                ref：非唯一性索引扫描，返回匹配某个单独值的所有行。例如查找name = "Bob"，查找的值唯一且固定，但是可能会有多个叫做bob的人。
                eq_ref：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描
                const：表示通过索引一次就找到，const用于比较primary key或者unique索引。因为只匹配一行数序数据，所以很快。（例如where中查询的是某个主键的值，其实就相当于查询一个常量）
                system：表只有一行记录（等于系统表），是const类型的特列，平时不会出现，可以忽略不计
                NULL
                从最好到最差 system>const>eq_ref>ref>range>index>All
                一般来说至少达到range级别，最好能达到ref级别
            possible_keys：可能应用在这张表中的索引（一个或多个）。查询涉及到的字段上若存在索引，则该索引会被列出，但不一定被查询实际使用
            key：实际使用的索引。如果为null，则表示没有使用索引。若查询中使用了覆盖索引，则该索引即出现在key列表中
                覆盖索引：查询的字段和创建的复合索引的字段恰好一一吻合（数量和顺序都一致），此时可以从索引中获取内容而不用全表扫描。因此可能会出现possible key为null，但是key不是null的情况
            key_len：表示索引中使用的字节数，可通过该列计算查询中使用的索引长度，在不损失精确性的前提下，长度越短越好。
                key_len显示的是索引字段的最大可能长度，而不是真正的实际使用长度。也即key_len是根据表定义计算得到，不是通过表内检索出的
                可以通过比较key_len的大小，判断一个复合索引中具体使用了几个索引
            ref：显示索引的哪一列被使用了，如果可能的话，是一个常数。哪些列或常量被用于查找索引列上的值。
                可能是查询中使用的是常量值（数值或者字符串），此时取值为const
                也可能是基于查询结果（先查出来一些结果，根据查出来的结果再去匹配）所在的列，此时取值为数据库名.表名.列名，例如database_name.table_name.column_name
                上述两种情况可能同时出现 
            rows：根据表统计信息及索引选取情况，大致估算出找到所需记录需要读取的行数（越小越好）
            Extra：包含不适合在其他列中但是十分重要的额外信息
                Using filesort：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。Mysql中无法利用表内索引完成的排序操作称为“文件排序”
                    说明：例如对表A创建了一个复合索引idx_col1_col2_col3，但是实际使用中根据col1查找，根据col3排序（跳过了col2），此时索引可以提供查找方面的优化，但是实际需要的排序结果和索引中的排序结果不同，不能直接通过索引的排序结果得到想要的排序结果。为了解决此问题，需要另起炉灶重新做一个排序。重新制作的排序不是表内索引的排序，称为“文件排序”。
                    这种情况比较危险，表示当前使用的索引功能部分失效（提供了查找的功能，但是没能提供排序的功能），存在较大的额外性能开支的风险。
                Using temporary：使用了内部临时表保存中间结果。mysql在对查询结果排序时使用临时表。常见于order by和group by
                    很危险，需要创建和删除临时表，非常影响系统性能
                    并不是所有的order by和group by都会引起。如果排序的列满足了使用索引的要求，就可以直接使用索引的排序结果，大大提高效率
                Using index：使用了覆盖索引，避免了直接访问表的数据行，效率提升。
                    如果同时出现了Using where，表明索引被用来执行索引键值的查找
                    如果没有出现using where，表明索引被用来读取数据，而不是执行查找动作
                    覆盖索引（Covering Index，也被称为索引覆盖）
                        理解一：select数据列只用从索引中就能取得，不必读取数据行。mysql可以利用索引返回select列表中的字段，而不必根据索引再次读取数据文件（也就是说只需要从索引中就可以获得本次查找的全部所需信息），也就是说查询列要被所建的索引覆盖。 
                    出现了Using index表示效率有意料之外的提升，是好事情。
                Using where：使用了where语句 
                Using join buffer：使用了连接缓存
                impossible where：where使用出现错误
                select tables optimized away：在没有group by子句的情况下，基于索引优化或者MyISAM存储引擎优化count（*）操作
                distinct：优化distinct操作，找到第一个匹配的元组后停止寻找同样值的动作。

索引分析
    单表
        mysql创建复合索引时使用了B+树。
        例如在使用索引idx_l1_l2_l3时，先对l1进行排序，再对l2和l3排序。
        面对查询需求 l1 = "value1", l2 > value2, order by l3时
            l1需要查询常量值，可以根据索引检索到l1=“value1”对应的子树
            l2查询范围，此时没有办法根据索引的树结构确定给定的结果，因此从l2（range类查询字段）以后的查询索引无效
            此时会产生Using filesort的情况
            为了消除这种情况，创建索引的时候不应该包括l2，所需要的索引应该为idx_l1_l3

    双表
        左连接索引加在右表上效果好（由左连接的特性决定，left join左表全都有（所以左表用不用索引区别不大），右表取部分）
        右连接索引加在左表上效果好
        如果索引已经确定了在左表上，可以考虑改变表的左右位置

    三表
        不加索引可能会出现Using join buffer
        连续左连接，第一个索引加在最右边的表上，第二个加在次右边的

    结论
        尽可能的减少Join语句中的NestedLoop（嵌套循环）循环总次数，“永远用小结果集驱动大的结果集”
        优先优化NestedLoop中的内层循环
        （重要）保证join语句中被驱动表上的join字段已经被索引
        无法保证优化且内存充足的情况下，适当增大buffer的空间（有时候Using join buffer不可避免）


索引失效
    目标是进行全值匹配（不是全表扫描）
        所有的字段都通过索引查找

    最佳左前缀法则
        查询从索引的最左列开始，并且不跳过中间的索引
        带头大哥不能死（从最左开始，建索引的第一个字段不能丢失）
        中间兄弟不能断（中间的索引不能跳过）（如果中间兄弟断了也会用到索引，用到断的地方之前，也即从全值索引退化成局部索引）

    不要在索引列上做任何操作
        计算、函数、类型转换
        否则会导致索引失效而转向全表扫描 

    存储引擎中不能使用范围条件右边的列
        范围之后全失效（范围本身用到了索引）
        type 不是ref，是range
        in,like,between,<或>等都会导致

    尽量使用覆盖索引（索引列和查询列一致），减少select *
        如果实现了覆盖索引，Extra会出现Using index
        此时如果检索条件中出现了范围查找，但是在检索覆盖的情况下，type还是ref，不会退化到range

    直接导致索引失效的情况
        mysql在使用不等于（!=或者<>）的时候无法使用索引会导致全表扫描
            不得已的时候，即便索引失效了也要使用
        
        is null和is not null也无法使用索引

        like以通配符匹配开头（like '%aabc……'）会导致索引失效
            只要通配符不在开头就行
            最好%跟在最右边，让可以使用索引的内容尽量长
            like查询是个range
            （重要）解决方案：使用覆盖索引 
            【？】%在右边时产生的范围和前面说的有一定区别，如果后面接着的查询项依然满足最佳左前缀法则，则后面的也可以使用索引

        字符串不加单引号导致索引失效
            不加引号导致类型不对，mysql会自动的进行类型转换

        or连接会导致索引失效
            少用（不是不用）
    
    一般order by是给范围
    group by表面上是分组（可能会有临时表产生），但是分组之前必排序，所以和order by的优化方式一样

一般性建议
    对单值索引，尽量选择针对当前查询过滤性更好的索引
    在选择组合索引的时候，当前查询中过滤性最好的字段在索引字段顺序中，位置越靠前越好
    在选择组合索引的时候，尽量选择可以能够包含当前查询中where子句中更多的字段
    尽可能通过分析统计信息和调整查询语句的写法来达到选择合适索引的目的
        
=========================================================
查询截取分析


分析
    1.观察，至少跑一天，看看生产的慢SQL情况
    2.开启慢查询日志，设置阈值（比如超过5秒的就是慢查询），抓取慢查询日志
    3.explain + 慢sql分析 （80%解决）
    4.show profile（90%+解决）
    5.运维经理 or DBA ，SQL数据库服务的参数调优

总结
    1.慢查询的开启并捕获
    2.explain + 慢sql分析
    3.show profile查询sql再Mysql服务器里面执行的细节和生命周期情况
    4.sql数据库服务器的参数调优

查询优化
    小表驱动大表
        永远小表驱动大表，小的数据集驱动大的数据集
        EXIST
            语法：SELEC …… FROM table WHERE EXIST (subquery)
            解释：将主查询的数据，放到子查询中做条件验证，根据验证结果（true或者false）来觉得主查询中的数据是否保留
        EXIST（subquery）只返回true或者false，因此子查询中的select在实际执行时会被忽略，一般可以写成 select 1或者select 'a'（即select一个随便的常量），没有区别
        EXIST子查询的实际执行中可能经过了优化，而不一定是逐条对比
        EXIST子查询往往可以用条件表达式或者其他join代替,何种最优要具体分析

        IN
            语法: SELECT …… FROM tableA WHERE list in (SELECT id FROM tableB)
        
        综合：如果子查询的结果集小于主查询，此时in优于exist。如果主查询小于子查询的结果集，exist较好

    ORDER BY优化
        mysql支持两种排序方式，index排序和filesort排序
        目的：尽量使用Index方式，避免使用Filesort
        满足两种情况会使用index排序
            order by语句使用索引最左前列
                index a_b_c (a,b,c)
                -ORDER BY a
                -ORDER BY a,b
                -ORDER BY a,b,c
                -ORDER BY a DESC,b DESC,C DESC（大家同升同降也可以使用，部分升部分降则失效）
            使用where子句和order by子句条件列组合满足索引最左前列（where查询内容为常量，不是范围）
        filesort有两种排序方法
            双路排序（两次IO）
                mysql4.1之前使用
                意思是扫描两次磁盘，最后得到数据
                读取行指针和order by列，对他们进行排序，然后扫描排序后的结果，按照列表中的值重新读取
                从磁盘中取排序字段，在buffer进行排序，再从磁盘中取其他字段（两次IO）
            单路排序（一次IO）
                从磁盘中读取查询需要的所有列
                按照order by列在buffer中进行排序，然后按照扫描结果输出
                会使用更多的空间（空间换时间），因此可能导致数据大小超过sort_buffer，退化成需要多次io的外部排序
                优化策略
                    参数调优，增大sort_buffer或者max_length_for_sort_data
                    不要使用select *
    
    GROUP BY优化
        和ORDER BY基本一致（group by实质是先排序在分组，遵照索引列的最佳做前缀原则）
        无法使用最佳左前缀的时候（一定会Using Filesort），增大sort_buffer或者max_length_for_sort_data
        where高于having，能用where筛选优先使用where

慢查询日志
    是mysql本身提供的一种日志记录，用于记录运行时间超过（大于，不是大于等于）了long-query_time（慢查询阈值）的sql
    慢查询日志默认关闭，需要手动开启，设置阈值（默认10秒，修改后需要重新连接或者新开一个窗口才能看到修改值）
    mysql重启后该功能又被关闭（该功能会影响性能），想要一直开启需要修改my.cnf文件
    记录的内容：运行时间，时间戳，是否有锁，提交的具体sql语句等

mysql日志分析工具
    mysqldumpslow命令

Show Profile
    mysql提供的可以用来分析当前会话语句执行的资源消耗情。可以用于sql的调优测量
    默认关闭状态，但是默认保存最近15次的运行结果
    使用show profile命令，显示使用的命令和耗时，并编号
    可以根据编号，查询到某次sql执行的具体步骤和每个步骤的资源消耗
    可以追溯sql完整的生命周期
    需要注意的参数
        converting HEAP to MyISAM：查询结果太大，内存不够，开始往磁盘拷贝
        Creating tmp table：创建临时表（拷贝数据到临时表，用完删除）
        Copying to tmp table on disk：把内存中的临时表复制到磁盘（非常危险）
        locked ：有锁

全局查询日志
    （重要）永远不要在生产环境使用，只能用于测试环境
